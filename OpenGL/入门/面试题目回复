

## 初级面试题
0.以单文件的HelloWorld举例，.cpp文件最后是怎么产生.exe文件的？描述下中间发生的步骤有哪些？
答：
先对该文件进行预处理，也就是常用的三个预处理命令；
1.文件包含：将该文件内容合并到源代码中
2.条件编译：有时候一个头文件可以引入另外一个头文件，条件编译防止头文件的重复包含和编译
3.宏定义：宏不占内存，编译器在编译之前对源代码做一些文本替换的处理


对然后该文件中的内容进行词法、语法分析，然后转化成二进制文件（.obj&.o文件后缀）

之后把二进制文件（.obj&.o文件后缀）和静态链接库（.lib&.a文件后缀）进行合成为.exe文件
静态链接库：可以看做是自己写的.h文件生成的.lib（Windows）或者.a（Linux&Unix）文件



1.遍历二维数组的时候，我们通常会这么写：
``` cpp
int data[10][10];
for(int i = 0; i < 10; ++i)
{
for(int j = 0; j < 10; ++j)
 {
  DoSomething(data[i][j]);
 }
}
```
请问为什么通常不会写成以下这样？两者的区别是什么？
``` cpp
int data[10][10];
for(int j = 0; j < 10; ++j)
{
 for(int i = 0; i < 10; ++i)
 {
  DoSomething(data[i][j]);
 }
}
```

答：
第一种是是每次遍历某一行的所有元素直至遍历完所有行，第二种是按列访问，每次遍历某一列元素，直至遍历完有列
第二种方法是每次访问二维数组每行的第一个元素，并非好的遍历方法


2.对于一个结构体来说，它内部会定义很多不同类型的数据，请计算下面结构体会占用的内存大小是多少：
按Win64平台的定义来计算：double是8字节，short是2字节，int是4字节
``` cpp
struct Data
{
    double a;
    short b;
    int c;
};
```
如果换一下定义顺序，现在的内存大小应该是多少：
``` cpp
struct Data
{
    short a;
    double b;
    int c;
}; 
```

答：大小是24


3.处理指针不当的时候会引起崩溃或者程序异常(栈溢出等)，请举一些你遇到过，或者能想到的场景，比如说使用空指针。

答：写单链表的时，可能非法访问空指针的值时，导致无法访问而出错


4.使用STL里的算法和容器，会让平时开发比较方便。请简答一些常用容器的问题：
* std::vector解决的问题是什么？为什么不用普通的数组？
* std::vector使用的内存类型是什么？它在增删改查的过程中，内存策略是怎么样的？
* std::map和std::unordered_map有什么区别？为什么要有两个map？
* std::map或者std::unordered_map查询某个key对应数据的时候要注意什么？
* 遍历这些容器的时候我们会用到迭代器，什么情况会出现迭代器失效的问题？

‘
答：
	1 vector是动态数组，可以随着插入和删除元素动态更改空间大小，更加灵活，从头尾都可以插入删除元素，
	普通数组初始就分配好固定大小的空间，且后续增加元素可能导致空间不足

  2 vector使用的是连续分配的内存空间，在容器中增加元素时。vector根据存储元素的大小，在内存上申请一个空间，用于存储数据，空间的大小通常会大于所存储元素的实际大小，并且预留出一部分预留的空间，以便再次增加数据时，可以不用重新开辟空间。

	当容器再次增加新的元素后，首先判断预留的空间是否够用，如果够用直接在预留空间中存储。如果预留的空间不够，需要在内存中开辟一	整块新的更大的空间，并将vector原来的存储的数据拷贝过来，存储到新的内存中，然后在新的内存中增加需要增加的元素，这样保证存储的空间是连续的。所开的空间会预留出一部分空间，以便后续增加数据。

  3.map和unordered_map都是键值存储的数据结构
  	map内部底层是一个使用红黑树保持元素相对有序的，查询元素时间复杂度通常是O(log n)，而unordered_map使用哈希映射存储元素，查询时间复杂度是O(1)

  	当要求需要对<key,value>元素有序存储时则用map,不需要时则使用unordered_map
  
  4.map查询某个key对应数据会判断当前map中是否有这个key，如果map不包含key，使用下标有一个危险的副作用，会在map中插入一个key的元素，value取默认值，返回value
  unordered_map底层时哈希存储，所以当没有key值会返回空

  5.迭代器失效分三种情况考虑，也是分三种数据结构考虑，分别为数组型，链表型，树型数据结构。
  	数组型数据结构：该数据结构的元素是分配在连续的内存中，insert和erase操作，都会使得删除点和插入点之后的元素挪位置，所以，插入点和删除掉之后的迭代器全部失效，也就是说insert(*iter)(或erase(*iter))，然后在iter++，是没有意义的。解决方法：erase(*iter)的返回值是下一个有效迭代器的值。 iter =cont.erase(iter);

	链表型数据结构：对于list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.解决办法两种，erase(*iter)会返回下一个有效迭代器的值，或者erase(iter++).

	树形数据结构： 使用红黑树来存储数据，插入不会使得任何迭代器失效；删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器.erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器。